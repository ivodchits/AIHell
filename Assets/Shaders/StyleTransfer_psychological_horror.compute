#pragma kernel StyleTransfer

Texture2D<float4> _SourceTex;
RWTexture2D<float4> _ResultTex;
float _Intensity;
float _Time;

// Perlin noise for subtle psychological distortions
float2 grad(int2 z)
{
    int n = z.x + z.y * 11111;
    n = (n << 13) ^ n;
    n = (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff;
    float2 gr = float2(n & 7, n >> 3 & 7);
    return float2(gr.x&1, gr.y&1)*2.0 - 1.0;
}

float noise(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);
    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(
        lerp(dot(grad(int2(i + int2(0,0))), f - float2(0,0)),
             dot(grad(int2(i + int2(1,0))), f - float2(1,0)), u.x),
        lerp(dot(grad(int2(i + int2(0,1))), f - float2(0,1)),
             dot(grad(int2(i + int2(1,1))), f - float2(1,1)), u.x), u.y);
}

float3 ApplyPsychologicalEffect(float3 color, uint2 id, uint2 texSize, float intensity)
{
    float2 uv = float2(id) / float2(texSize);
    
    // Create subtle reality distortion
    float2 distortionUV = uv;
    float distortion = noise(uv * 5.0 + _Time * 0.1) * 0.01 * intensity;
    distortionUV += float2(distortion);
    
    // Sample with subtle distortion
    uint2 distortedPos = uint2(
        clamp(distortionUV.x * texSize.x, 0, texSize.x - 1),
        clamp(distortionUV.y * texSize.y, 0, texSize.y - 1)
    );
    float3 distortedColor = _SourceTex[distortedPos].rgb;
    
    // Apply psychological color manipulation
    float3 result = distortedColor;
    
    // Add subliminal patterns
    float pattern = noise(uv * 20.0 + _Time * 0.05);
    float subliminal = smoothstep(0.4, 0.6, pattern);
    result = lerp(result, result * (1.0 - subliminal * 0.1), intensity);
    
    // Create subtle shadow movement
    float shadow = noise(uv * 3.0 - _Time * 0.1);
    float shadowMask = smoothstep(0.3, 0.7, shadow);
    result = lerp(result, result * 0.8, shadowMask * intensity * 0.2);
    
    // Add barely perceptible faces/patterns
    float faces = 0.0;
    for(int i = 0; i < 3; i++)
    {
        float2 faceUV = uv * float2(1.0, 2.0) + float2(sin(_Time * 0.1), cos(_Time * 0.1)) * 0.1;
        float faceMask = noise(faceUV * (5.0 + float(i)) + _Time * 0.05);
        faces += smoothstep(0.5, 0.51, faceMask) * 0.1;
    }
    result = lerp(result, float3(0.1, 0.1, 0.1), faces * intensity);
    
    // Subtle vignette that pulses with anxiety
    float2 vignetteUV = uv * 2.0 - 1.0;
    float vignette = 1.0 - dot(vignetteUV, vignetteUV);
    vignette *= 1.0 + sin(_Time) * 0.1 * intensity;
    result *= lerp(1.0, vignette, intensity * 0.3);
    
    // Add subtle color bleeding
    float bleed = noise(uv * 10.0 + _Time * 0.2);
    result.r += bleed * intensity * 0.05;
    result.b -= bleed * intensity * 0.05;
    
    // Create subtle depth distortion
    float depth = noise(uv * 4.0 - _Time * 0.15);
    float depthMask = smoothstep(0.4, 0.6, depth);
    result = lerp(result, result * (1.0 + depthMask * 0.2), intensity * 0.3);
    
    // Add almost imperceptible movement
    float movement = noise(uv * 8.0 + _Time * 0.1);
    result *= 1.0 + movement * intensity * 0.05;
    
    // Subtle reality fragmentation
    float fragmentation = step(0.98 - intensity * 0.1, noise(uv * 15.0 + floor(_Time * 0.5)));
    result = lerp(result, 1.0 - result, fragmentation * 0.1);
    
    // Create unsettling symmetry
    float2 symmetryUV = float2(abs(uv.x - 0.5) * 2.0, uv.y);
    float symmetry = noise(symmetryUV * 10.0 + _Time * 0.1);
    result = lerp(result, result * (1.0 + symmetry * 0.1), intensity * 0.2);
    
    return result;
}

[numthreads(8,8,1)]
void StyleTransfer(uint3 id : SV_DispatchThreadID)
{
    uint2 texSize;
    _ResultTex.GetDimensions(texSize.x, texSize.y);
    
    if (id.x >= texSize.x || id.y >= texSize.y)
        return;

    // Get original color
    float4 originalColor = _SourceTex[id.xy];
    
    // Apply psychological horror effect
    float3 final = ApplyPsychologicalEffect(originalColor.rgb, id.xy, texSize, _Intensity);
    
    // Store result
    _ResultTex[id.xy] = float4(final, originalColor.a);
}