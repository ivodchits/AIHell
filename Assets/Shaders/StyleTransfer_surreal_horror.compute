#pragma kernel StyleTransfer

Texture2D<float4> _SourceTex;
RWTexture2D<float4> _ResultTex;
float _Intensity;
float _Time;

// Fractal Brownian Motion for surreal distortion
float2 hash2(float2 p)
{
    return frac(sin(float2(dot(p,float2(127.1,311.7)), dot(p,float2(269.5,183.3)))) * 43758.5453);
}

float noise(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);
    f = f * f * (3.0 - 2.0 * f);
    
    float2 c00 = hash2(i);
    float2 c10 = hash2(i + float2(1.0, 0.0));
    float2 c01 = hash2(i + float2(0.0, 1.0));
    float2 c11 = hash2(i + float2(1.0, 1.0));
    
    return lerp(
        lerp(dot(c00, f - float2(0.0, 0.0)), dot(c10, f - float2(1.0, 0.0)), f.x),
        lerp(dot(c01, f - float2(0.0, 1.0)), dot(c11, f - float2(1.0, 1.0)), f.x),
        f.y
    );
}

float fbm(float2 p)
{
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    
    for(int i = 0; i < 5; i++)
    {
        value += amplitude * noise(p * frequency);
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    
    return value;
}

float3 ApplySurrealDistortion(float3 color, uint2 id, uint2 texSize, float intensity)
{
    float2 uv = float2(id) / float2(texSize);
    
    // Create surreal distortion field
    float2 distortionUV = uv * 3.0 + _Time * 0.1;
    float distortion = fbm(distortionUV) * 2.0 - 1.0;
    
    // Apply wave-like reality distortion
    float2 waveUV = uv;
    waveUV.x += sin(uv.y * 10.0 + _Time) * 0.02 * intensity;
    waveUV.y += cos(uv.x * 10.0 + _Time) * 0.02 * intensity;
    
    // Sample with distortion
    uint2 distortedPos = uint2(
        clamp(waveUV.x * texSize.x + distortion * intensity * 10.0, 0, texSize.x - 1),
        clamp(waveUV.y * texSize.y + distortion * intensity * 10.0, 0, texSize.y - 1)
    );
    
    float3 distortedColor = _SourceTex[distortedPos].rgb;
    
    // Apply color manipulation
    float3 result = lerp(color, distortedColor, intensity * 0.7);
    
    // Add surreal color shifting
    float colorShift = sin(_Time * 2.0 + distortion) * 0.2 * intensity;
    result.r = lerp(result.r, result.r + colorShift, intensity);
    result.b = lerp(result.b, result.b - colorShift, intensity);
    
    // Apply reality fracturing
    float fracture = step(0.97 - intensity * 0.2, noise(uv * 20.0 + _Time));
    result = lerp(result, 1.0 - result, fracture * intensity);
    
    // Add void patches
    float void = smoothstep(0.5, 0.7, fbm(uv * 5.0 + _Time * 0.2));
    result = lerp(result, float3(0.02, 0.0, 0.03), void * intensity * 0.5);
    
    // Apply dimension bleeding
    float bleed = fbm(uv * 8.0 - _Time * 0.1) * intensity;
    float3 bleedColor = float3(
        sin(_Time + uv.x) * 0.5 + 0.5,
        cos(_Time + uv.y) * 0.5 + 0.5,
        sin(_Time * 0.5) * 0.5 + 0.5
    );
    result = lerp(result, bleedColor, bleed * 0.3);
    
    // Reality edge detection
    float2 edgeUV = uv * 2.0 - 1.0;
    float edge = 1.0 - smoothstep(0.4, 0.5, abs(length(edgeUV) - 0.8));
    result *= 1.0 - edge * intensity * 0.3;
    
    // Add temporal artifacts
    float glitch = step(0.98 - intensity * 0.1, noise(uv * 50.0 + floor(_Time * 20.0)));
    result = lerp(result, float3(1,1,1), glitch);
    
    return result;
}

[numthreads(8,8,1)]
void StyleTransfer(uint3 id : SV_DispatchThreadID)
{
    uint2 texSize;
    _ResultTex.GetDimensions(texSize.x, texSize.y);
    
    if (id.x >= texSize.x || id.y >= texSize.y)
        return;

    // Get original color
    float4 originalColor = _SourceTex[id.xy];
    
    // Apply surreal horror effect
    float3 final = ApplySurrealDistortion(originalColor.rgb, id.xy, texSize, _Intensity);
    
    // Store result
    _ResultTex[id.xy] = float4(final, originalColor.a);
}